// Code generated by protoc-gen-go. DO NOT EDIT.
// source: notification.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//Sample data messages
type PushNotificationEventDataReq struct {
	EventType            string               `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	RequestData          *any.Any             `protobuf:"bytes,2,opt,name=request_data,json=requestData,proto3" json:"request_data,omitempty"`
	ResponseData         *any.Any             `protobuf:"bytes,3,opt,name=response_data,json=responseData,proto3" json:"response_data,omitempty"`
	CreatedOn            *timestamp.Timestamp `protobuf:"bytes,4,opt,name=created_on,json=createdOn,proto3" json:"created_on,omitempty"`
	CreatedBy            *timestamp.Timestamp `protobuf:"bytes,5,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PushNotificationEventDataReq) Reset()         { *m = PushNotificationEventDataReq{} }
func (m *PushNotificationEventDataReq) String() string { return proto.CompactTextString(m) }
func (*PushNotificationEventDataReq) ProtoMessage()    {}
func (*PushNotificationEventDataReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{0}
}

func (m *PushNotificationEventDataReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushNotificationEventDataReq.Unmarshal(m, b)
}
func (m *PushNotificationEventDataReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushNotificationEventDataReq.Marshal(b, m, deterministic)
}
func (m *PushNotificationEventDataReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushNotificationEventDataReq.Merge(m, src)
}
func (m *PushNotificationEventDataReq) XXX_Size() int {
	return xxx_messageInfo_PushNotificationEventDataReq.Size(m)
}
func (m *PushNotificationEventDataReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PushNotificationEventDataReq.DiscardUnknown(m)
}

var xxx_messageInfo_PushNotificationEventDataReq proto.InternalMessageInfo

func (m *PushNotificationEventDataReq) GetEventType() string {
	if m != nil {
		return m.EventType
	}
	return ""
}

func (m *PushNotificationEventDataReq) GetRequestData() *any.Any {
	if m != nil {
		return m.RequestData
	}
	return nil
}

func (m *PushNotificationEventDataReq) GetResponseData() *any.Any {
	if m != nil {
		return m.ResponseData
	}
	return nil
}

func (m *PushNotificationEventDataReq) GetCreatedOn() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedOn
	}
	return nil
}

func (m *PushNotificationEventDataReq) GetCreatedBy() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedBy
	}
	return nil
}

type ReqEventData struct {
	Recipients           []string `protobuf:"bytes,1,rep,name=recipients,proto3" json:"recipients,omitempty"`
	HtmlBody             string   `protobuf:"bytes,2,opt,name=html_body,json=htmlBody,proto3" json:"html_body,omitempty"`
	Subject              string   `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqEventData) Reset()         { *m = ReqEventData{} }
func (m *ReqEventData) String() string { return proto.CompactTextString(m) }
func (*ReqEventData) ProtoMessage()    {}
func (*ReqEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{1}
}

func (m *ReqEventData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReqEventData.Unmarshal(m, b)
}
func (m *ReqEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReqEventData.Marshal(b, m, deterministic)
}
func (m *ReqEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqEventData.Merge(m, src)
}
func (m *ReqEventData) XXX_Size() int {
	return xxx_messageInfo_ReqEventData.Size(m)
}
func (m *ReqEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ReqEventData proto.InternalMessageInfo

func (m *ReqEventData) GetRecipients() []string {
	if m != nil {
		return m.Recipients
	}
	return nil
}

func (m *ReqEventData) GetHtmlBody() string {
	if m != nil {
		return m.HtmlBody
	}
	return ""
}

func (m *ReqEventData) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

type ResEventData struct {
	Recipients           []string `protobuf:"bytes,1,rep,name=recipients,proto3" json:"recipients,omitempty"`
	HtmlBody             string   `protobuf:"bytes,2,opt,name=html_body,json=htmlBody,proto3" json:"html_body,omitempty"`
	Subject              string   `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	Response             string   `protobuf:"bytes,4,opt,name=response,proto3" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResEventData) Reset()         { *m = ResEventData{} }
func (m *ResEventData) String() string { return proto.CompactTextString(m) }
func (*ResEventData) ProtoMessage()    {}
func (*ResEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{2}
}

func (m *ResEventData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResEventData.Unmarshal(m, b)
}
func (m *ResEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResEventData.Marshal(b, m, deterministic)
}
func (m *ResEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResEventData.Merge(m, src)
}
func (m *ResEventData) XXX_Size() int {
	return xxx_messageInfo_ResEventData.Size(m)
}
func (m *ResEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ResEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ResEventData proto.InternalMessageInfo

func (m *ResEventData) GetRecipients() []string {
	if m != nil {
		return m.Recipients
	}
	return nil
}

func (m *ResEventData) GetHtmlBody() string {
	if m != nil {
		return m.HtmlBody
	}
	return ""
}

func (m *ResEventData) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *ResEventData) GetResponse() string {
	if m != nil {
		return m.Response
	}
	return ""
}

//Notification request contains the type of notification to be processed
type NotificationRequest struct {
	//tells about the type of notification , three types are possible email, sms, realtime
	NotificationId string `protobuf:"bytes,1,opt,name=notification_id,json=notificationId,proto3" json:"notification_id,omitempty"`
	//this is the data of the notification , for email this will contain sender,receiver and attachment
	//data, for sms sender, receiver,body and for real time the type of notification query(history,
	//brodcasting,publishing ) and the data of notification
	NotificationData     *any.Any `protobuf:"bytes,2,opt,name=notification_data,json=notificationData,proto3" json:"notification_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotificationRequest) Reset()         { *m = NotificationRequest{} }
func (m *NotificationRequest) String() string { return proto.CompactTextString(m) }
func (*NotificationRequest) ProtoMessage()    {}
func (*NotificationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{3}
}

func (m *NotificationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NotificationRequest.Unmarshal(m, b)
}
func (m *NotificationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NotificationRequest.Marshal(b, m, deterministic)
}
func (m *NotificationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotificationRequest.Merge(m, src)
}
func (m *NotificationRequest) XXX_Size() int {
	return xxx_messageInfo_NotificationRequest.Size(m)
}
func (m *NotificationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NotificationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NotificationRequest proto.InternalMessageInfo

func (m *NotificationRequest) GetNotificationId() string {
	if m != nil {
		return m.NotificationId
	}
	return ""
}

func (m *NotificationRequest) GetNotificationData() *any.Any {
	if m != nil {
		return m.NotificationData
	}
	return nil
}

//Emailrequest contains information about the email
type EmailRequest struct {
	//this contains the email address of sender
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	//this is an array of strings containing the recipients email addresses
	Recipient []string `protobuf:"bytes,2,rep,name=recipient,proto3" json:"recipient,omitempty"`
	//email addresses for carbon copy
	Cc []string `protobuf:"bytes,3,rep,name=cc,proto3" json:"cc,omitempty"`
	//email addresses for blind carbon copy
	Bcc []string `protobuf:"bytes,4,rep,name=bcc,proto3" json:"bcc,omitempty"`
	//email address to which recipient can reply. Leave empty if don't want reply
	ReplyTo string `protobuf:"bytes,5,opt,name=reply_to,json=replyTo,proto3" json:"reply_to,omitempty"`
	//email body in html
	HtmlBody string `protobuf:"bytes,6,opt,name=html_body,json=htmlBody,proto3" json:"html_body,omitempty"`
	//email body in text form , if html rendering is not supported in receiver's client
	TextBody string `protobuf:"bytes,7,opt,name=text_body,json=textBody,proto3" json:"text_body,omitempty"`
	//subject of the email
	Subject string `protobuf:"bytes,8,opt,name=subject,proto3" json:"subject,omitempty"`
	//file details if attachment if present in the email
	FileName string `protobuf:"bytes,9,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	//character encoding for email
	Charset string `protobuf:"bytes,10,opt,name=charset,proto3" json:"charset,omitempty"`
	//file data if attachment is available
	FileData             []byte   `protobuf:"bytes,11,opt,name=file_data,json=fileData,proto3" json:"file_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmailRequest) Reset()         { *m = EmailRequest{} }
func (m *EmailRequest) String() string { return proto.CompactTextString(m) }
func (*EmailRequest) ProtoMessage()    {}
func (*EmailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{4}
}

func (m *EmailRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmailRequest.Unmarshal(m, b)
}
func (m *EmailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmailRequest.Marshal(b, m, deterministic)
}
func (m *EmailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmailRequest.Merge(m, src)
}
func (m *EmailRequest) XXX_Size() int {
	return xxx_messageInfo_EmailRequest.Size(m)
}
func (m *EmailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EmailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EmailRequest proto.InternalMessageInfo

func (m *EmailRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EmailRequest) GetRecipient() []string {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *EmailRequest) GetCc() []string {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *EmailRequest) GetBcc() []string {
	if m != nil {
		return m.Bcc
	}
	return nil
}

func (m *EmailRequest) GetReplyTo() string {
	if m != nil {
		return m.ReplyTo
	}
	return ""
}

func (m *EmailRequest) GetHtmlBody() string {
	if m != nil {
		return m.HtmlBody
	}
	return ""
}

func (m *EmailRequest) GetTextBody() string {
	if m != nil {
		return m.TextBody
	}
	return ""
}

func (m *EmailRequest) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *EmailRequest) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *EmailRequest) GetCharset() string {
	if m != nil {
		return m.Charset
	}
	return ""
}

func (m *EmailRequest) GetFileData() []byte {
	if m != nil {
		return m.FileData
	}
	return nil
}

//SmsRequest contains information about the sms
type SmsRequest struct {
	//this contains the sender id , it can be phone number, shortcode or alphanumeric string
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	//this contains the recipients mobile numbers
	Recipient []string `protobuf:"bytes,2,rep,name=recipient,proto3" json:"recipient,omitempty"`
	//this contains body of the sms
	Body                 string   `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SmsRequest) Reset()         { *m = SmsRequest{} }
func (m *SmsRequest) String() string { return proto.CompactTextString(m) }
func (*SmsRequest) ProtoMessage()    {}
func (*SmsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{5}
}

func (m *SmsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SmsRequest.Unmarshal(m, b)
}
func (m *SmsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SmsRequest.Marshal(b, m, deterministic)
}
func (m *SmsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SmsRequest.Merge(m, src)
}
func (m *SmsRequest) XXX_Size() int {
	return xxx_messageInfo_SmsRequest.Size(m)
}
func (m *SmsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SmsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SmsRequest proto.InternalMessageInfo

func (m *SmsRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *SmsRequest) GetRecipient() []string {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *SmsRequest) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

//this conatins the data of real time notification
type SendRealTimeRequest struct {
	//array of channel names in which data is to be published
	Channels []string `protobuf:"bytes,1,rep,name=channels,proto3" json:"channels,omitempty"`
	//data to publish
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendRealTimeRequest) Reset()         { *m = SendRealTimeRequest{} }
func (m *SendRealTimeRequest) String() string { return proto.CompactTextString(m) }
func (*SendRealTimeRequest) ProtoMessage()    {}
func (*SendRealTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{6}
}

func (m *SendRealTimeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SendRealTimeRequest.Unmarshal(m, b)
}
func (m *SendRealTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SendRealTimeRequest.Marshal(b, m, deterministic)
}
func (m *SendRealTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendRealTimeRequest.Merge(m, src)
}
func (m *SendRealTimeRequest) XXX_Size() int {
	return xxx_messageInfo_SendRealTimeRequest.Size(m)
}
func (m *SendRealTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendRealTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendRealTimeRequest proto.InternalMessageInfo

func (m *SendRealTimeRequest) GetChannels() []string {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *SendRealTimeRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

//Response of notification
type NotificationResponse struct {
	ErrorStatus          string   `protobuf:"bytes,1,opt,name=error_status,json=errorStatus,proto3" json:"error_status,omitempty"`
	ErrorCode            int32    `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotificationResponse) Reset()         { *m = NotificationResponse{} }
func (m *NotificationResponse) String() string { return proto.CompactTextString(m) }
func (*NotificationResponse) ProtoMessage()    {}
func (*NotificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{7}
}

func (m *NotificationResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NotificationResponse.Unmarshal(m, b)
}
func (m *NotificationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NotificationResponse.Marshal(b, m, deterministic)
}
func (m *NotificationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotificationResponse.Merge(m, src)
}
func (m *NotificationResponse) XXX_Size() int {
	return xxx_messageInfo_NotificationResponse.Size(m)
}
func (m *NotificationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NotificationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NotificationResponse proto.InternalMessageInfo

func (m *NotificationResponse) GetErrorStatus() string {
	if m != nil {
		return m.ErrorStatus
	}
	return ""
}

func (m *NotificationResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

//Email response, this contains the message id of email
type EmailResponse struct {
	MessageId            string   `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmailResponse) Reset()         { *m = EmailResponse{} }
func (m *EmailResponse) String() string { return proto.CompactTextString(m) }
func (*EmailResponse) ProtoMessage()    {}
func (*EmailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{8}
}

func (m *EmailResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmailResponse.Unmarshal(m, b)
}
func (m *EmailResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmailResponse.Marshal(b, m, deterministic)
}
func (m *EmailResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmailResponse.Merge(m, src)
}
func (m *EmailResponse) XXX_Size() int {
	return xxx_messageInfo_EmailResponse.Size(m)
}
func (m *EmailResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EmailResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EmailResponse proto.InternalMessageInfo

func (m *EmailResponse) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

//this contains the message id using which you can get information about the sms
type SmsResponse struct {
	MessageId            string   `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SmsResponse) Reset()         { *m = SmsResponse{} }
func (m *SmsResponse) String() string { return proto.CompactTextString(m) }
func (*SmsResponse) ProtoMessage()    {}
func (*SmsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_736a457d4a5efa07, []int{9}
}

func (m *SmsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SmsResponse.Unmarshal(m, b)
}
func (m *SmsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SmsResponse.Marshal(b, m, deterministic)
}
func (m *SmsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SmsResponse.Merge(m, src)
}
func (m *SmsResponse) XXX_Size() int {
	return xxx_messageInfo_SmsResponse.Size(m)
}
func (m *SmsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SmsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SmsResponse proto.InternalMessageInfo

func (m *SmsResponse) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func init() {
	proto.RegisterType((*PushNotificationEventDataReq)(nil), "proto.PushNotificationEventDataReq")
	proto.RegisterType((*ReqEventData)(nil), "proto.ReqEventData")
	proto.RegisterType((*ResEventData)(nil), "proto.ResEventData")
	proto.RegisterType((*NotificationRequest)(nil), "proto.NotificationRequest")
	proto.RegisterType((*EmailRequest)(nil), "proto.EmailRequest")
	proto.RegisterType((*SmsRequest)(nil), "proto.SmsRequest")
	proto.RegisterType((*SendRealTimeRequest)(nil), "proto.SendRealTimeRequest")
	proto.RegisterType((*NotificationResponse)(nil), "proto.NotificationResponse")
	proto.RegisterType((*EmailResponse)(nil), "proto.EmailResponse")
	proto.RegisterType((*SmsResponse)(nil), "proto.SmsResponse")
}

func init() { proto.RegisterFile("notification.proto", fileDescriptor_736a457d4a5efa07) }

var fileDescriptor_736a457d4a5efa07 = []byte{
	// 752 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x4f, 0xdb, 0x48,
	0x14, 0x57, 0x12, 0x20, 0x99, 0x17, 0xc3, 0xc2, 0x80, 0x90, 0x71, 0x60, 0x37, 0xeb, 0xcb, 0xe6,
	0xb0, 0x0a, 0xab, 0xec, 0x01, 0xed, 0x61, 0x0f, 0xb0, 0x9b, 0x95, 0x90, 0x56, 0xb4, 0x75, 0xa2,
	0xaa, 0x37, 0x6b, 0x62, 0x3f, 0x88, 0xab, 0xf8, 0x03, 0xcf, 0xa4, 0xaa, 0x8f, 0x3d, 0xf5, 0x4f,
	0xa9, 0xfa, 0x5f, 0x56, 0xf3, 0xe1, 0x60, 0x07, 0x4a, 0x51, 0x51, 0x4f, 0x99, 0xf7, 0x7b, 0x5f,
	0x7e, 0xbf, 0xf9, 0xbd, 0x09, 0xd0, 0x24, 0x15, 0xd1, 0x75, 0x14, 0x30, 0x11, 0xa5, 0xc9, 0x30,
	0xcb, 0x53, 0x91, 0xd2, 0x4d, 0xf5, 0xe3, 0x1c, 0xdd, 0xa4, 0xe9, 0xcd, 0x02, 0x4f, 0x95, 0x35,
	0x5b, 0x5e, 0x9f, 0xb2, 0xa4, 0xd0, 0x11, 0x4e, 0x6f, 0xdd, 0x85, 0x71, 0x26, 0x4a, 0xe7, 0x2f,
	0xeb, 0x4e, 0x11, 0xc5, 0xc8, 0x05, 0x8b, 0x33, 0x1d, 0xe0, 0x7e, 0x6a, 0xc2, 0xf1, 0xcb, 0x25,
	0x9f, 0x5f, 0x55, 0x5a, 0x8f, 0xdf, 0x61, 0x22, 0xfe, 0x65, 0x82, 0x79, 0x78, 0x4b, 0x4f, 0x00,
	0x50, 0xda, 0xbe, 0x28, 0x32, 0xb4, 0x1b, 0xfd, 0xc6, 0x80, 0x78, 0x44, 0x21, 0xd3, 0x22, 0x43,
	0x7a, 0x06, 0x56, 0x8e, 0xb7, 0x4b, 0xe4, 0xc2, 0x0f, 0x99, 0x60, 0x76, 0xb3, 0xdf, 0x18, 0x74,
	0x47, 0x07, 0x43, 0xdd, 0x77, 0x58, 0xf6, 0x1d, 0x9e, 0x27, 0x85, 0xd7, 0x35, 0x91, 0xb2, 0x34,
	0xfd, 0x0b, 0xb6, 0x73, 0xe4, 0x59, 0x9a, 0x70, 0xd4, 0x99, 0xad, 0x47, 0x32, 0xad, 0x32, 0xd4,
	0xa4, 0x42, 0x90, 0x23, 0x13, 0x18, 0xfa, 0x69, 0x62, 0x6f, 0xa8, 0x3c, 0xe7, 0x5e, 0xde, 0xb4,
	0x9c, 0xd4, 0x23, 0x26, 0xfa, 0x45, 0x52, 0x4d, 0x9d, 0x15, 0xf6, 0xe6, 0x93, 0x53, 0x2f, 0x0a,
	0x17, 0xc1, 0xf2, 0xf0, 0x76, 0xc5, 0x0d, 0xfd, 0x19, 0x20, 0xc7, 0x20, 0xca, 0x22, 0x4c, 0x04,
	0xb7, 0x1b, 0xfd, 0xd6, 0x80, 0x78, 0x15, 0x84, 0xf6, 0x80, 0xcc, 0x45, 0xbc, 0xf0, 0x67, 0x69,
	0x58, 0x28, 0x5a, 0x88, 0xd7, 0x91, 0xc0, 0x45, 0x1a, 0x16, 0xd4, 0x86, 0x36, 0x5f, 0xce, 0xde,
	0x62, 0x20, 0xd4, 0xdc, 0xc4, 0x2b, 0x4d, 0xf7, 0x43, 0x43, 0xf6, 0xe1, 0x3f, 0xba, 0x0f, 0x75,
	0xa0, 0x53, 0x92, 0xaa, 0x28, 0x24, 0xde, 0xca, 0x96, 0xdf, 0xb0, 0x5f, 0x15, 0x84, 0xa7, 0xef,
	0x8d, 0xfe, 0x06, 0x3f, 0x55, 0x25, 0xea, 0x47, 0xa1, 0x11, 0xc4, 0x4e, 0x15, 0xbe, 0x0c, 0xe9,
	0x39, 0xec, 0xd5, 0x02, 0xbf, 0x29, 0x8d, 0xdd, 0x6a, 0xb8, 0x1c, 0xdb, 0xfd, 0xdc, 0x04, 0x6b,
	0x1c, 0xb3, 0x68, 0x51, 0x36, 0x3f, 0x84, 0x2d, 0x8e, 0x49, 0x88, 0xb9, 0xe9, 0x69, 0x2c, 0x7a,
	0x0c, 0x64, 0xc5, 0x86, 0xdd, 0x54, 0xf4, 0xdc, 0x01, 0x74, 0x07, 0x9a, 0x41, 0x60, 0xb7, 0x14,
	0xdc, 0x0c, 0x02, 0xba, 0x0b, 0xad, 0x59, 0x10, 0xd8, 0x1b, 0x0a, 0x90, 0x47, 0x7a, 0x24, 0x89,
	0xc8, 0x16, 0x85, 0x2f, 0x52, 0x25, 0x08, 0xe2, 0xb5, 0x95, 0x3d, 0x4d, 0xeb, 0xd4, 0x6e, 0xad,
	0x51, 0xdb, 0x03, 0x22, 0xf0, 0xbd, 0xd0, 0xce, 0xb6, 0x76, 0x4a, 0x60, 0x9d, 0xf7, 0x4e, 0x9d,
	0xf7, 0x1e, 0x90, 0xeb, 0x68, 0x81, 0x7e, 0xc2, 0x62, 0xb4, 0x89, 0x4e, 0x93, 0xc0, 0x15, 0x8b,
	0x51, 0xa6, 0x05, 0x73, 0x96, 0x73, 0x14, 0x36, 0xe8, 0x34, 0x63, 0xae, 0xd2, 0x14, 0x93, 0xdd,
	0x7e, 0x63, 0x60, 0xe9, 0x34, 0xc5, 0xd5, 0x6b, 0x80, 0x49, 0xcc, 0x9f, 0x47, 0x14, 0x85, 0x0d,
	0x35, 0x89, 0x96, 0x89, 0x3a, 0xbb, 0x63, 0xd8, 0x9f, 0x60, 0x12, 0x7a, 0xc8, 0x16, 0x72, 0x25,
	0xca, 0x06, 0x0e, 0x74, 0x82, 0x39, 0x4b, 0x12, 0x5c, 0x94, 0x7a, 0x5c, 0xd9, 0xb2, 0xcc, 0xea,
	0xb2, 0x2d, 0x4f, 0x9d, 0xdd, 0x37, 0x70, 0x50, 0x57, 0x93, 0x96, 0x19, 0xfd, 0x15, 0x2c, 0xcc,
	0xf3, 0x34, 0xf7, 0xb9, 0x60, 0x62, 0xc9, 0xcd, 0xe7, 0x76, 0x15, 0x36, 0x51, 0x90, 0x7a, 0x7d,
	0x54, 0x48, 0x90, 0x86, 0xa8, 0x8a, 0x6e, 0x7a, 0x44, 0x21, 0xff, 0xa4, 0x21, 0xba, 0x43, 0xd8,
	0x36, 0x1a, 0x31, 0x25, 0x4f, 0x00, 0x62, 0xe4, 0x9c, 0xdd, 0xe0, 0x9d, 0x38, 0x89, 0x41, 0x2e,
	0x43, 0xf7, 0x77, 0xe8, 0x2a, 0xa2, 0x9e, 0x14, 0x3d, 0x0a, 0xea, 0x5b, 0xc0, 0x27, 0x9a, 0xc7,
	0xff, 0x61, 0x4f, 0x9e, 0x6a, 0x2e, 0xea, 0x68, 0x3d, 0x0f, 0x1f, 0x58, 0x1b, 0xa7, 0xf7, 0xa0,
	0x4f, 0x7f, 0xc3, 0xe8, 0x63, 0x13, 0x68, 0xad, 0x94, 0x7c, 0x56, 0x39, 0x7d, 0x05, 0x87, 0xeb,
	0x4d, 0xd4, 0xa4, 0xdf, 0xdf, 0x89, 0x5e, 0xe9, 0xdb, 0xac, 0xfa, 0x26, 0xf1, 0xb3, 0xea, 0xd9,
	0xeb, 0xf5, 0x4a, 0xa5, 0x3c, 0x5a, 0xf4, 0xf0, 0xde, 0x0b, 0x30, 0x96, 0xff, 0x58, 0xa3, 0xff,
	0xa0, 0xab, 0x46, 0x34, 0x34, 0x9f, 0x01, 0xc8, 0x93, 0x99, 0x7a, 0xdf, 0x14, 0xac, 0x3e, 0x09,
	0xce, 0x41, 0x1d, 0x34, 0x8c, 0xfe, 0x0d, 0x64, 0x12, 0x97, 0x97, 0xf5, 0x07, 0xb4, 0xe5, 0x49,
	0x0e, 0xba, 0x67, 0xa2, 0xef, 0x56, 0xc5, 0xa1, 0x55, 0xc8, 0xa4, 0x4f, 0x61, 0xa7, 0x1c, 0xc3,
	0xd4, 0xb8, 0x00, 0xab, 0xba, 0x06, 0xab, 0xe1, 0x1e, 0xd8, 0x8d, 0xaf, 0x0d, 0x37, 0xdb, 0x52,
	0xf6, 0x9f, 0x5f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe5, 0x53, 0x9e, 0x1f, 0xe4, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NotificationsSenderClient is the client API for NotificationsSender service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotificationsSenderClient interface {
	//method to fan out notifications to all notification types
	// fan out logic here
	SendNotifications(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error)
}

type notificationsSenderClient struct {
	cc *grpc.ClientConn
}

func NewNotificationsSenderClient(cc *grpc.ClientConn) NotificationsSenderClient {
	return &notificationsSenderClient{cc}
}

func (c *notificationsSenderClient) SendNotifications(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error) {
	out := new(NotificationResponse)
	err := c.cc.Invoke(ctx, "/proto.NotificationsSender/SendNotifications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationsSenderServer is the server API for NotificationsSender service.
type NotificationsSenderServer interface {
	//method to fan out notifications to all notification types
	// fan out logic here
	SendNotifications(context.Context, *NotificationRequest) (*NotificationResponse, error)
}

func RegisterNotificationsSenderServer(s *grpc.Server, srv NotificationsSenderServer) {
	s.RegisterService(&_NotificationsSender_serviceDesc, srv)
}

func _NotificationsSender_SendNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsSenderServer).SendNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.NotificationsSender/SendNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsSenderServer).SendNotifications(ctx, req.(*NotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotificationsSender_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.NotificationsSender",
	HandlerType: (*NotificationsSenderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNotifications",
			Handler:    _NotificationsSender_SendNotifications_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notification.proto",
}

// NotificationsTypesClient is the client API for NotificationsTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotificationsTypesClient interface {
	//method to send emails
	// check bussiness setting
	// get template, get data , render template
	SendNotificationEmails(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error)
	//method to send sms
	SendNotificationSms(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error)
	//send real time notifications, get history of realTimeNotifications
	SendNotificationRealTime(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type notificationsTypesClient struct {
	cc *grpc.ClientConn
}

func NewNotificationsTypesClient(cc *grpc.ClientConn) NotificationsTypesClient {
	return &notificationsTypesClient{cc}
}

func (c *notificationsTypesClient) SendNotificationEmails(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error) {
	out := new(NotificationResponse)
	err := c.cc.Invoke(ctx, "/proto.NotificationsTypes/SendNotificationEmails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsTypesClient) SendNotificationSms(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error) {
	out := new(NotificationResponse)
	err := c.cc.Invoke(ctx, "/proto.NotificationsTypes/SendNotificationSms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsTypesClient) SendNotificationRealTime(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/proto.NotificationsTypes/SendNotificationRealTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationsTypesServer is the server API for NotificationsTypes service.
type NotificationsTypesServer interface {
	//method to send emails
	// check bussiness setting
	// get template, get data , render template
	SendNotificationEmails(context.Context, *NotificationRequest) (*NotificationResponse, error)
	//method to send sms
	SendNotificationSms(context.Context, *NotificationRequest) (*NotificationResponse, error)
	//send real time notifications, get history of realTimeNotifications
	SendNotificationRealTime(context.Context, *NotificationRequest) (*empty.Empty, error)
}

func RegisterNotificationsTypesServer(s *grpc.Server, srv NotificationsTypesServer) {
	s.RegisterService(&_NotificationsTypes_serviceDesc, srv)
}

func _NotificationsTypes_SendNotificationEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsTypesServer).SendNotificationEmails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.NotificationsTypes/SendNotificationEmails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsTypesServer).SendNotificationEmails(ctx, req.(*NotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationsTypes_SendNotificationSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsTypesServer).SendNotificationSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.NotificationsTypes/SendNotificationSms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsTypesServer).SendNotificationSms(ctx, req.(*NotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationsTypes_SendNotificationRealTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsTypesServer).SendNotificationRealTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.NotificationsTypes/SendNotificationRealTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsTypesServer).SendNotificationRealTime(ctx, req.(*NotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotificationsTypes_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.NotificationsTypes",
	HandlerType: (*NotificationsTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNotificationEmails",
			Handler:    _NotificationsTypes_SendNotificationEmails_Handler,
		},
		{
			MethodName: "SendNotificationSms",
			Handler:    _NotificationsTypes_SendNotificationSms_Handler,
		},
		{
			MethodName: "SendNotificationRealTime",
			Handler:    _NotificationsTypes_SendNotificationRealTime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notification.proto",
}

// EmailSenderClient is the client API for EmailSender service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EmailSenderClient interface {
	//this sends email to all recipients
	SendEmails(ctx context.Context, in *EmailRequest, opts ...grpc.CallOption) (*EmailResponse, error)
}

type emailSenderClient struct {
	cc *grpc.ClientConn
}

func NewEmailSenderClient(cc *grpc.ClientConn) EmailSenderClient {
	return &emailSenderClient{cc}
}

func (c *emailSenderClient) SendEmails(ctx context.Context, in *EmailRequest, opts ...grpc.CallOption) (*EmailResponse, error) {
	out := new(EmailResponse)
	err := c.cc.Invoke(ctx, "/proto.EmailSender/SendEmails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmailSenderServer is the server API for EmailSender service.
type EmailSenderServer interface {
	//this sends email to all recipients
	SendEmails(context.Context, *EmailRequest) (*EmailResponse, error)
}

func RegisterEmailSenderServer(s *grpc.Server, srv EmailSenderServer) {
	s.RegisterService(&_EmailSender_serviceDesc, srv)
}

func _EmailSender_SendEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailSenderServer).SendEmails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EmailSender/SendEmails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailSenderServer).SendEmails(ctx, req.(*EmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EmailSender_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.EmailSender",
	HandlerType: (*EmailSenderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEmails",
			Handler:    _EmailSender_SendEmails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notification.proto",
}

// SmsSenderClient is the client API for SmsSender service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SmsSenderClient interface {
	//this sends sms to all recipients
	SendSms(ctx context.Context, in *SmsRequest, opts ...grpc.CallOption) (*SmsResponse, error)
}

type smsSenderClient struct {
	cc *grpc.ClientConn
}

func NewSmsSenderClient(cc *grpc.ClientConn) SmsSenderClient {
	return &smsSenderClient{cc}
}

func (c *smsSenderClient) SendSms(ctx context.Context, in *SmsRequest, opts ...grpc.CallOption) (*SmsResponse, error) {
	out := new(SmsResponse)
	err := c.cc.Invoke(ctx, "/proto.SmsSender/SendSms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SmsSenderServer is the server API for SmsSender service.
type SmsSenderServer interface {
	//this sends sms to all recipients
	SendSms(context.Context, *SmsRequest) (*SmsResponse, error)
}

func RegisterSmsSenderServer(s *grpc.Server, srv SmsSenderServer) {
	s.RegisterService(&_SmsSender_serviceDesc, srv)
}

func _SmsSender_SendSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmsSenderServer).SendSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SmsSender/SendSms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmsSenderServer).SendSms(ctx, req.(*SmsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SmsSender_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.SmsSender",
	HandlerType: (*SmsSenderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendSms",
			Handler:    _SmsSender_SendSms_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notification.proto",
}

// RealTimeSenderClient is the client API for RealTimeSender service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RealTimeSenderClient interface {
	//sends real time notifications, broadcasting, publishing
	SendRealTime(ctx context.Context, in *SendRealTimeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type realTimeSenderClient struct {
	cc *grpc.ClientConn
}

func NewRealTimeSenderClient(cc *grpc.ClientConn) RealTimeSenderClient {
	return &realTimeSenderClient{cc}
}

func (c *realTimeSenderClient) SendRealTime(ctx context.Context, in *SendRealTimeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/proto.RealTimeSender/SendRealTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RealTimeSenderServer is the server API for RealTimeSender service.
type RealTimeSenderServer interface {
	//sends real time notifications, broadcasting, publishing
	SendRealTime(context.Context, *SendRealTimeRequest) (*empty.Empty, error)
}

func RegisterRealTimeSenderServer(s *grpc.Server, srv RealTimeSenderServer) {
	s.RegisterService(&_RealTimeSender_serviceDesc, srv)
}

func _RealTimeSender_SendRealTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRealTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RealTimeSenderServer).SendRealTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RealTimeSender/SendRealTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RealTimeSenderServer).SendRealTime(ctx, req.(*SendRealTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RealTimeSender_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.RealTimeSender",
	HandlerType: (*RealTimeSenderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendRealTime",
			Handler:    _RealTimeSender_SendRealTime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notification.proto",
}
